# 2024. 11. 26

## [Session_활용_과제_프로젝트](https://github.com/SulHyunRyung/SessionControl)
* 코드 리뷰 및 로직 수정
* Session의 접근 방식이나 사용 이유에 대해 조금 더 알게된 계기였음.

## Servlet Filter

## Servlet Filter란?

* 사용자 인증이나 로깅과 같은 기능들은 모든 서블릿이나 JSP가 공통적으로 필요로 함.
* 이러한 공통적인 기능들을 서블릿이 호출되기 전에 수행(전처리)되게 하고 싶거나
* 서블릿이 호출 되고 난 뒤에 수행(후처리) 하고 싶으면 공통적인 기능들을 서블릿 필터로 구현하면 된다.

## Filter의 라이프 사이클
* 필터는 서블릿과 비슷한 라이프사이클을 가지며 생성, 초기화, 필터, 종료의 4단계로 이루어짐
* 또한 서블릿 컨테이너는 필터 객체가 초기화 파라미터에 접근하는데 사용하는 환경설정 객체(FilterConfig)의 레퍼런스를 제공한다. 
* 서블릿 컨테이너가 필터의 init() 메소드를 호출하면 필터 인터페이스는 바로 요청을 처리할 수 있는 상태가 된다.
* 서블릿이 service() 메소드를 이용해서 요청을 처리한 것 처럼 필터는 doFilter() 메소드를 통해서 요청을 처리한다. 
* 모든 요청에 대한 처리가 끝나면 destroy() 메소드가 호출되면서 필터는 비활성 상태로 변경된다.

## FilterChain
* 필터는 연속적인 작용을 수행한다. 필터 객체가 수행해야 할 부분인 doFilter() 메소드로 인자로 전달되는 것이 FilterChain 객체이다. 
* FilterChain 객체는 필터의 수행과정을 연속적으로 하기 위한 방법이다. 웹 컨테이너가 FIlterConfig 객체와 함께 FilterChain 인터페이스를 구현한 객체를 생성한다.

## doFilter() 메소드
* 가장 핵심인 Filtering이 이루어지는 메소드이다.

![FilterExample](https://github.com/user-attachments/assets/d6b3c527-499c-450c-b77b-7911d951ca54)

* 필터는 한번만 수행되는 것이 아니라, 요청을 받을 때 수행되고 chain.doFilter()를 통해 다음 부분으로 넘겨준다. 
* 다음 모든 부분이 모두 수행되면 다시 필터로 완전한 응답객체와 함께 제어권이 넘어오게 된다. 
* 위의 코드처럼 chain.doFilter()를 기준으로 전처리 부분과 후처리 부분으로 나누는 이유다.

​따라서 chain.doFIlter()가 doFilter() 메소드 안에 없다면 서블릿의 수행결과를 알 수 없다. 
즉 chain,doFilter() 메소드를 사용하여 다음 단계인 진짜 서블릿을 수행한 후 결과를 다시 받는 것이다.
